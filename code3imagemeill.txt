import os
import cv2
import numpy as np
import imagehash
from PIL import Image
from pdf2image import convert_from_path

def create_directories(output_dir):
    figures_dir = os.path.join(output_dir, "figures_extracted")
    os.makedirs(figures_dir, exist_ok=True)
    return figures_dir

def extract_figures_from_pdf(pdf_path, output_dir="output", margin=50):
    figures_dir = create_directories(output_dir)
    
    print("ğŸš€ Conversion du PDF en images...")
    images = convert_from_path(pdf_path, dpi=300)
    
    figures = []
    for page_num, img_pil in enumerate(images, start=1):
        print(f"ğŸ” Traitement de la page {page_num}...")
        img_np = np.array(img_pil)
        gray = cv2.cvtColor(img_np, cv2.COLOR_RGB2GRAY)

        # ğŸ“Œ RÃ©duction du bruit et amÃ©lioration du contraste
        gray = cv2.GaussianBlur(gray, (5,5), 0)
        gray = cv2.equalizeHist(gray)

        # ğŸ“Œ DÃ©tection amÃ©liorÃ©e des bords
        edges = cv2.Canny(gray, 30, 150)

        # ğŸ“Œ DÃ©tection des contours avec expansion automatique
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        detected_areas = [
            cv2.boundingRect(contour) for contour in contours 
            if cv2.boundingRect(contour)[2] > 250 and cv2.boundingRect(contour)[3] > 250  # ğŸ“Œ On prend seulement les grandes figures
        ]
        merged_areas = merge_overlapping_rectangles(detected_areas, margin)

        for i, (x1, y1, x2, y2) in enumerate(merged_areas):
            x1, y1 = max(0, x1 - margin), max(0, y1 - margin)  # ğŸ“Œ Expansion pour Ã©viter la coupe
            x2, y2 = min(img_pil.width, x2 + margin), min(img_pil.height, y2 + margin)

            # ğŸ“Œ Correction spÃ©ciale pour dÃ©tecter et capturer **entiÃ¨rement** les tableaux
            if is_table_structure(gray[y1:y2, x1:x2]):
                x1, y1 = max(0, x1 - 20), max(0, y1 - 20)  # Expansion spÃ©ciale
                x2, y2 = min(img_pil.width, x2 + 20), min(img_pil.height, y2 + 20)

            if x2 > x1 and y2 > y1:
                figure = img_pil.crop((x1, y1, x2, y2))

                # ğŸ“Œ VÃ©rification de la taille minimale pour Ã©viter les zooms excessifs
                if (x2 - x1) > 500 and (y2 - y1) > 500:
                    figure_filename = f"_page_{page_num}_Figure_{i + 1}.jpeg"
                    figure_path = os.path.join(figures_dir, figure_filename)
                    figure.save(figure_path, format="JPEG")
                    figures.append(figure_path)
                else:
                    print(f"âš ï¸ Figure ignorÃ©e car trop petite : {x1, y1, x2, y2}")
    
    print(f"âœ… Extraction terminÃ©e : {len(figures)} figures dÃ©tectÃ©es.")
    return figures

def merge_overlapping_rectangles(rectangles, margin=50):
    """ ğŸ“Œ Fusionner les rectangles qui se chevauchent pour Ã©viter les figures coupÃ©es """
    if not rectangles:
        return []
    
    rectangles = sorted(rectangles, key=lambda r: (r[1], r[0]))  # ğŸ“Œ Trier par position
    merged = []
    
    for rect in rectangles:
        x1, y1, w, h = rect
        x2, y2 = x1 + w, y1 + h
        x1, y1, x2, y2 = x1 - margin, y1 - margin, x2 + margin, y2 + margin  # ğŸ“Œ Expansion des marges

        if not merged:
            merged.append((x1, y1, x2, y2))
            continue

        mx1, my1, mx2, my2 = merged[-1]

        if x1 <= mx2 and y1 <= my2:
            merged[-1] = (min(x1, mx1), min(y1, my1), max(x2, mx2), max(y2, my2))  # ğŸ“Œ Fusionner si chevauchement
        else:
            merged.append((x1, y1, x2, y2))
    
    return merged

def is_table_structure(region):
    """ ğŸ“Œ DÃ©tecte si une rÃ©gion ressemble Ã  un tableau pour Ã©viter quâ€™il soit coupÃ© """
    edges = cv2.Canny(region, 50, 150)
    lines = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=50, minLineLength=50, maxLineGap=5)
    return lines is not None  # ğŸ“Œ Si on dÃ©tecte plusieurs lignes, c'est sÃ»rement un tableau

def remove_duplicate_figures(figures):
    print("ğŸ” VÃ©rification des doublons...")
    hashes = {}
    unique_figures = []
    
    for figure_path in figures:
        img = Image.open(figure_path)
        img_hash = imagehash.phash(img)
        
        if img_hash not in hashes:
            hashes[img_hash] = figure_path
            unique_figures.append(figure_path)
        else:
            print(f"âŒ Figure en double dÃ©tectÃ©e : {figure_path} (SupprimÃ©e)")
            os.remove(figure_path)
    
    print(f"âœ… {len(unique_figures)} figures uniques conservÃ©es.")
    return unique_figures

def main():
    pdf_path = r"F:\app\Downloads\TW-Formation MÃ©tiers.pdf" # ğŸ“Œ Modifier avec le bon chemin
    
    print("ğŸš€ Extraction des figures et diagrammes...")
    figures = extract_figures_from_pdf(pdf_path)
    
    print("ğŸš€ Suppression des doublons...")
    unique_figures = remove_duplicate_figures(figures)
    
    print("âœ… Processus terminÃ© ! Seules les figures et diagrammes uniques sont conservÃ©s.")

if __name__ == "__main__":
    main()
